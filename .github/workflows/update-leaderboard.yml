name: Update leaderboard snapshot

on:
  schedule:
    - cron: "*/30 * * * *" # 30분마다 갱신 시도
  workflow_dispatch:

permissions:
  contents: write

jobs:
  fetch:
    runs-on: ubuntu-latest
    env:
      URL_LEADER: https://dacon.io/competitions/official/236624/leaderboard
      URL_CODESHARE: https://dacon.io/competitions/official/236624/codeshare
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Playwright
        run: |
          npm install -D playwright
          npx playwright install chromium

      - name: Create scraper script
        run: |
          cat > scraper.js <<'SCRIPT'
          const { chromium } = require('playwright');
          const fs = require('fs');
          const path = require('path');

          (async () => {
            const browser = await chromium.launch({ headless: true });
            const page = await browser.newPage();
            
            // 데이터 디렉토리 생성
            const dataDir = path.join(__dirname, 'data');
            if (!fs.existsSync(dataDir)) {
              fs.mkdirSync(dataDir);
            }

            console.log('Fetching leaderboard...');
            await page.goto(process.env.URL_LEADER, { waitUntil: 'networkidle' });
            const leaderboardHtml = await page.content();
            fs.writeFileSync(path.join(dataDir, 'leaderboard.html'), leaderboardHtml);
            console.log(`Leaderboard saved: ${leaderboardHtml.length} bytes`);

            console.log('Fetching codeshare...');
            await page.goto(process.env.URL_CODESHARE, { waitUntil: 'networkidle' });
            
            // 더보기 버튼을 여러 번 클릭하여 모든 게시글 로드
            let clickCount = 0;
            const maxClicks = 50; // 최대 클릭 횟수 제한
            
            while (clickCount < maxClicks) {
              try {
                // 더보기 버튼 찾기
                const loadMoreButton = await page.locator('button.bgBtn.primary--text, button:has-text("더보기")').first();
                
                // 버튼이 보이는지 확인
                const isVisible = await loadMoreButton.isVisible({ timeout: 2000 }).catch(() => false);
                
                if (!isVisible) {
                  console.log('더보기 버튼이 더 이상 없습니다.');
                  break;
                }
                
                console.log(`더보기 버튼 클릭 #${clickCount + 1}`);
                await loadMoreButton.click();
                
                // 새 콘텐츠 로드 대기
                await page.waitForTimeout(1000);
                clickCount++;
              } catch (error) {
                console.log('더보기 버튼 클릭 종료:', error.message);
                break;
              }
            }

            console.log(`총 ${clickCount}번 더보기 클릭 완료`);

            // 모든 게시글 데이터 추출
            const posts = await page.evaluate(() => {
              const items = [];
              
              // 게시글 카드 찾기 (구조에 따라 셀렉터 조정 필요)
              const cards = document.querySelectorAll('a[href*="/codeshare/"]');
              
              cards.forEach(card => {
                try {
                  // 제목 추출
                  const titleEl = card.querySelector('.title, [class*="title"]') || card;
                  const title = titleEl.textContent.trim();
                  
                  // 조회수 추출 - 여러 가능한 셀렉터 시도
                  let views = 0;
                  const viewSelectors = [
                    '.d-flex.align-center.text-caption.justify-center.py-0',
                    '[class*="view"]',
                    '.text-caption'
                  ];
                  
                  for (const selector of viewSelectors) {
                    const viewEl = card.querySelector(selector);
                    if (viewEl) {
                      const viewText = viewEl.textContent.trim();
                      const match = viewText.match(/(\d+)/);
                      if (match) {
                        views = parseInt(match[1]);
                        break;
                      }
                    }
                  }
                  
                  // 카드 전체에서 숫자 찾기 (fallback)
                  if (views === 0) {
                    const allText = card.textContent;
                    const numbers = allText.match(/\d+/g);
                    if (numbers && numbers.length > 0) {
                      // 가장 작은 숫자를 조회수로 간주 (보통 조회수가 가장 작음)
                      views = Math.min(...numbers.map(n => parseInt(n)));
                    }
                  }
                  
                  if (title && title.length > 0) {
                    items.push({ title, views });
                  }
                } catch (e) {
                  console.error('게시글 파싱 오류:', e);
                }
              });
              
              return items;
            });

            console.log(`총 ${posts.length}개 게시글 추출`);
            
            // 추출된 데이터를 JSON으로 저장
            fs.writeFileSync(
              path.join(dataDir, 'codeshare-posts.json'),
              JSON.stringify(posts, null, 2)
            );

            await browser.close();
          })();
          SCRIPT

      - name: Run scraper
        run: node scraper.js

      - name: Build summary JSON
        run: |
          python3 - <<'PY'
          import re, json, pathlib, datetime, random

          root = pathlib.Path("data")
          leader_html = root.joinpath("leaderboard.html").read_text()
          
          # 1) votes from leaderboard
          pattern = re.compile(r'<li class="vote[^>]*>\s*<span[^>]*>\s*([\d,]+)\s*</span>.*?<li class="date', re.S)
          votes = [int(x.replace(",", "")) for x in pattern.findall(leader_html)]

          # 2) codeshare posts from Playwright scraping
          posts_file = root.joinpath("codeshare-posts.json")
          posts = json.loads(posts_file.read_text()) if posts_file.exists() else []

          # dedupe by title (keep min views)
          dedup = {}
          for p in posts:
              if p["title"] not in dedup or p["views"] < dedup[p["title"]]["views"]:
                  dedup[p["title"]] = p
          posts_unique = list(dedup.values())

          posts_sorted = sorted(posts_unique, key=lambda x: x["views"])
          low_pool = posts_sorted[:30] if posts_sorted else []
          sample_base = low_pool[:15] if len(low_pool) > 15 else low_pool
          sample_size = min(5, len(sample_base))
          low_view_sample = random.sample(sample_base, sample_size) if sample_size else []

          data = {
              "totalVotes": sum(votes),
              "voteValues": votes,
              "teamCount": len(votes),
              "updatedAt": datetime.datetime.utcnow().isoformat() + "Z",
              "lowViewSample": low_view_sample,
              "allPosts": posts_unique,
          }

          path = root.joinpath("summary.json")
          path.write_text(json.dumps(data, ensure_ascii=False, indent=2))
          print(f"votes: {len(votes)} items, sum {sum(votes)}")
          print(f"codeshare posts(raw): {len(posts)}, unique: {len(posts_unique)}, sample size: {len(low_view_sample)}")
          print(f"low sample: {low_view_sample}")
          PY

      - name: Commit & push if changed
        env:
          GIT_AUTHOR_NAME: github-actions
          GIT_AUTHOR_EMAIL: actions@users.noreply.github.com
          GIT_COMMITTER_NAME: github-actions
          GIT_COMMITTER_EMAIL: actions@users.noreply.github.com
        run: |
          set -euo pipefail
          if git status --porcelain | grep .; then
            git add data/
            git commit -m "chore: refresh leaderboard snapshot"
            git push
          else
            echo "No changes to commit."
          fi